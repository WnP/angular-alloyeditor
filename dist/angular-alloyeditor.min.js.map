{"version":3,"sources":["angular-alloyeditor.js"],"names":["global","factory","define","amd","angular","this","alloyEditorDirective","$parse","$timeout","compile","tElement","tAttrs","id","Error","post","postLink","pre","preLink","$scope","$element","$attributes","$controllers","initialize","forEach","event","alloyEditorCtrl","onEvent","ngModelCtrl","$setViewValue","nativeEditor","getData","$watch","readonly","newValue","oldValue","setReadOnly","Boolean","$setTouched","onready","syncEditor","ready","then","setData","$viewValue","callback","fire","noSnapshot","$render","editorElement","find","attr","createInstance","directive","controller","controllerAs","require","restrict","template","AlloyEditorController","$q","readyDeferred","promise","instance","get","elementId","AlloyEditor","editable","resolve","listener","asyncListener","args","arguments","applyListener","apply","$apply","on","removeListener","vm","defer","$on","destroy","module","$inject"],"mappings":"CAAA,SAAUA,EAAQC,GAChB,YACsB,mBAAXC,SAAyBA,OAAOC,IAAKD,QAAQ,WAAYD,GAC/DA,EAAQG,UACZC,KAAM,SAASD,GAChB,YASA,SAASE,GAAqBC,EAAQC,GAYpC,QAASC,GAAQC,EAAUC,GACzB,IAAKA,EAAOC,GACV,KAAMC,OAAM,mDAEd,QACEC,KAAMC,EACNC,IAAKC,GAIT,QAASF,GAASG,EAAQC,EAAUC,EAAaC,GAU/C,QAASC,MAEN,SAAU,QAAQC,QAAQ,SAAuBC,GAChDC,EAAgBC,QAAQF,EAAO,WAC7BG,EAAYC,cAAcH,EAAgBI,eAAeC,WAAa,QAI1EZ,EAAOa,OAAOX,EAAYY,SAAU,SAASC,EAAUC,GACjDD,IAAaC,GACfT,EAAgBI,eAAeM,YAAYC,QAAQH,MAIvDR,EAAgBC,QAAQ,QAAS,WAC/BC,EAAYU,gBAKd7B,EAAS,WACPD,EAAOa,EAAYkB,SAASpB,KAIhC,QAASqB,KACPd,EAAgBe,QAAQC,KAAK,WAC3BhB,EAAgBI,eAAea,QAAQf,EAAYgB,YAAc,IAC/DC,SAAU,WAIRnB,EAAgBI,eAAegB,KAAK,mBAEtCC,YAAY,MA3ClB,GAAIrB,GAAkBJ,EAAa,GAC/BM,EAAcN,EAAa,EAG/BI,GAAgBe,QAAQC,KAAKnB,GAG7BK,EAAYoB,QAAUR,EA0CxB,QAAStB,GAAQC,EAAQC,EAAUC,EAAaC,GAC9C,GAAII,GAAkBJ,EAAa,GAC/B2B,EAAgB7B,EAAS8B,KAAK,MAClCD,GAAcE,KAAK,KAAM9B,EAAYR,GAAK,YAC1Ca,EAAgB0B,eAAeH,EAAcE,KAAK,OA3EpD,GAAIE,IACF3C,QAASA,EACT4C,WAAY,wBACZC,aAAc,kBACdC,SAAU,cAAe,WACzBC,SAAU,IACVC,SAAU,mCAGZ,OAAOL,GAwET,QAASM,GAAsBC,EAAIzC,EAAQV,GAkBzC,QAASgC,KACP,MAAOoB,GAAcC,QAGvB,QAAShC,KACP,MAAOiC,GAASC,IAAI,gBAUtB,QAASZ,GAAea,GAMtB,MALAF,GAAWG,YAAYC,SAASF,GAChCtC,EAAQ,gBAAiB,WACvBkC,EAAcO,SAAQ,KAGjBL,EAYT,QAASpC,GAAQF,EAAO4C,GAGtB,QAASC,KACP,GAAIC,GAAOC,SACX/D,GAAS,WACPgE,EAAcC,MAAM,KAAMH,KAI9B,QAASE,KACP,GAAIF,GAAOC,SACXrD,GAAOwD,OAAO,WACZN,EAASK,MAAM,KAAMH,KAKzB,MAjBAzC,KAAe8C,GAAGnD,EAAO6C,GAiBlB,WACLxC,IAAe+C,eAAepD,EAAOgD,IArEzC,GAEIV,GAFAe,EAAKxE,KACLuD,EAAgBD,EAAGmB,OAGvBD,GAAG1B,eAAiBA,EACpB0B,EAAGnD,QAAUA,EACbmD,EAAGrC,MAAQA,EACXqC,EAAGhD,aAAeA,EAGlBX,EAAO6D,IAAI,WAAY,WAErBnB,EAAcC,QAAQpB,KAAK,WACzBqB,EAASkB,cAvGf5E,EACG6E,OAAO,kBACP5B,WAAW,wBAAyBK,GACpCN,UAAU,cAAe9C,GAE5BA,EAAqB4E,SAAW,SAAU,YAkF1CxB,EAAsBwB,SAAW,KAAM,SAAU","file":"angular-alloyeditor.min.js","sourcesContent":["(function(global, factory) {\n  'use strict';\n  if (typeof define === 'function' && define.amd) define(['angular'], factory);\n  else factory(angular);\n})(this, function(angular) {\n  'use strict';\n\n  angular\n    .module('alloyeditor', [])\n    .controller('AlloyEditorController', AlloyEditorController)\n    .directive('alloyEditor', alloyEditorDirective);\n\n  alloyEditorDirective.$inject = ['$parse', '$timeout'];\n\n  function alloyEditorDirective($parse, $timeout) {\n    var directive = {\n      compile: compile,\n      controller: 'AlloyEditorController',\n      controllerAs: 'alloyEditorCtrl',\n      require: ['alloyEditor', 'ngModel'],\n      restrict: 'E',\n      template: '<div class=\"alloy-editor\"></div>'\n    };\n\n    return directive;\n\n    function compile(tElement, tAttrs) {\n      if (!tAttrs.id) {\n        throw Error('The alloy-editor element must have id attribute.');\n      }\n      return {\n        post: postLink,\n        pre: preLink\n      };\n    }\n\n    function postLink($scope, $element, $attributes, $controllers) {\n      var alloyEditorCtrl = $controllers[0];\n      var ngModelCtrl = $controllers[1];\n\n      // Initialize the editor content when it is ready.\n      alloyEditorCtrl.ready().then(initialize);\n\n      // Set editor data when view data change.\n      ngModelCtrl.$render = syncEditor;\n\n      function initialize() {\n        // Sync view on specific events.\n        ['change', 'blur'].forEach(function syncViewEvent(event) {\n          alloyEditorCtrl.onEvent(event, function syncView() {\n            ngModelCtrl.$setViewValue(alloyEditorCtrl.nativeEditor().getData() || '');\n          });\n        });\n\n        $scope.$watch($attributes.readonly, function(newValue, oldValue) {\n          if (newValue !== oldValue) {\n            alloyEditorCtrl.nativeEditor().setReadOnly(Boolean(newValue));\n          }\n        });\n\n        alloyEditorCtrl.onEvent('focus', function syncTouched() {\n          ngModelCtrl.$setTouched();\n        });\n\n        // Defer the ready handler calling to ensure that the editor is\n        // completely ready and populated with data.\n        $timeout(function() {\n          $parse($attributes.onready)($scope);\n        });\n      }\n\n      function syncEditor() {\n        alloyEditorCtrl.ready().then(function() {\n          alloyEditorCtrl.nativeEditor().setData(ngModelCtrl.$viewValue || '', {\n            callback: function() {\n              // Amends the top of the undo stack with the current DOM changes\n              // ie: merge snapshot with the first empty one\n              // http://docs.ckeditor.com/#!/api/CKEDITOR.editor-event-updateSnapshot\n              alloyEditorCtrl.nativeEditor().fire('updateSnapshot');\n            },\n            noSnapshot: true\n          });\n        });\n      }\n    }\n\n    function preLink($scope, $element, $attributes, $controllers) {\n      var alloyEditorCtrl = $controllers[0];\n      var editorElement = $element.find('div');\n      editorElement.attr('id', $attributes.id + '-content');\n      alloyEditorCtrl.createInstance(editorElement.attr('id'));\n    }\n  }\n\n  AlloyEditorController.$inject = ['$q', '$scope', '$timeout'];\n\n  function AlloyEditorController($q, $scope, $timeout) {\n    var vm = this;\n    var readyDeferred = $q.defer();\n    var instance;\n\n    vm.createInstance = createInstance;\n    vm.onEvent = onEvent;\n    vm.ready = ready;\n    vm.nativeEditor = nativeEditor;\n\n    // Destroy editor when the scope is destroyed.\n    $scope.$on('$destroy', function onDestroy() {\n      // do not delete too fast or pending events will throw errors\n      readyDeferred.promise.then(function() {\n        instance.destroy();\n      });\n    });\n\n    function ready() {\n      return readyDeferred.promise;\n    }\n\n    function nativeEditor() {\n      return instance.get('nativeEditor');\n    }\n\n    /**\n     * Invoke create method on AlloyEditor passing the ID of the node you want to edit.\n     *\n     * @param {String} elementId Id of the node you want to edit.\n     *\n     * @returns {Object} Instance of AlloyEditor.\n     */\n    function createInstance(elementId) {\n      instance = AlloyEditor.editable(elementId);\n      onEvent('instanceReady', function() {\n        readyDeferred.resolve(true);\n      });\n\n      return instance;\n    }\n\n    /**\n     * Listen on events of a given type.\n     * This make all event asynchronous and wrapped in $scope.$apply.\n     *\n     * @param {String} event Type-name of event listener.\n     * @param {Function} listener Exevute this function on listener.\n     *\n     * @returns {Function} Deregistration function for this listener.\n     */\n    function onEvent(event, listener) {\n      nativeEditor().on(event, asyncListener);\n\n      function asyncListener() {\n        var args = arguments;\n        $timeout(function() {\n          applyListener.apply(null, args);\n        });\n      }\n\n      function applyListener() {\n        var args = arguments;\n        $scope.$apply(function() {\n          listener.apply(null, args);\n        });\n      }\n\n      // Return the deregistration function\n      return function $off() {\n        nativeEditor().removeListener(event, applyListener);\n      };\n    }\n  }\n});\n"],"sourceRoot":"/source/"}